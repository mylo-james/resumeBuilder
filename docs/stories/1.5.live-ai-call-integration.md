# Story 1.5: Live AI Call Integration

## Status

Draft

## Story

**As a** developer, **I want** to update the backend API route to call the OpenAI API, **so that** the application can
generate dynamic, personalized content based on the user's input.

## Acceptance Criteria

1. The `/api/generate` route is modified to accept a job description from the user.
2. The route securely calls the OpenAI API and passes the job description as input.
3. The route correctly processes the JSON response from the OpenAI API.
4. The frontend now displays dynamic content based on the user's input.

## Tasks / Subtasks

- [ ] Install and configure OpenAI SDK (AC: 2)
  - [ ] Install OpenAI SDK: `npm install openai` [Source: architecture/architecture-tech-stack.md#tech-stack-overview]
  - [ ] Create OpenAI client with proper authentication
  - [ ] Set up environment variables for API key
- [ ] Create OpenAI service layer (AC: 2)
  - [ ] Implement `src/lib/services/openai.ts` service [Source: architecture/architecture-project-structure.md#srclib]
  - [ ] Create prompt templates in `src/lib/prompts/resume-prompt.ts` [Source:
        architecture/architecture-project-structure.md#srclib]
  - [ ] Implement prompt engineering for resume and cover letter generation
- [ ] Update API route (AC: 1, 2, 3)
  - [ ] Modify `src/app/api/generate/route.ts` to call OpenAI API [Source:
        architecture/architecture-project-structure.md#srcapp]
  - [ ] Accept job description input and pass to OpenAI service
  - [ ] Process OpenAI response and return structured data
  - [ ] Handle API rate limiting and retries
- [ ] Update frontend to handle dynamic content (AC: 4)
  - [ ] Ensure frontend displays dynamic content from API response
  - [ ] Maintain existing UI components and loading states
- [ ] Implement comprehensive error handling
  - [ ] Handle OpenAI API failures, invalid responses, rate limiting
  - [ ] Implement proper error responses to frontend
- [ ] Write comprehensive tests
  - [ ] Unit tests for OpenAI service with mocked responses [Source:
        architecture/architecture-testing-strategy.md#testing-pyramid-overview]
  - [ ] Integration tests with mocked OpenAI API [Source:
        architecture/architecture-testing-strategy.md#testing-pyramid-overview]
  - [ ] E2E tests for AI generation flow [Source:
        architecture/architecture-testing-strategy.md#testing-pyramid-overview]

## Dev Notes

- Previous Story Insights

  - Builds on Story 1.4's API route structure and frontend integration.
  - Replaces static data with dynamic AI-generated content.

- Data Models

  - Request format: `{ jobDescription: string, jobUrl?: string }`
  - OpenAI response processing to match expected frontend format
  - Error response format for API failures

- API Specifications

  - POST endpoint: `/api/generate` (updated from Story 1.4) [Source:
    architecture/architecture-project-structure.md#srcapp]
  - OpenAI API integration with proper authentication
  - Rate limiting and retry logic for external API calls

- Component Specifications

  - Maintain existing UI components from previous stories
  - Ensure loading states work with potentially longer AI generation times
  - Error handling for AI generation failures

- File Locations

  - OpenAI service: `src/lib/services/openai.ts` [Source: architecture/architecture-project-structure.md#srclib]
  - Prompt templates: `src/lib/prompts/` [Source: architecture/architecture-project-structure.md#srclib]
  - Updated API route: `src/app/api/generate/route.ts` [Source: architecture/architecture-project-structure.md#srcapp]

- Testing Requirements

  - Mock OpenAI API responses for testing [Source: architecture/architecture-testing-strategy.md#testing-best-practices]
  - Unit tests for OpenAI service logic [Source: architecture/architecture-testing-strategy.md#testing-pyramid-overview]
  - Integration tests with mocked external API [Source:
    architecture/architecture-testing-strategy.md#testing-pyramid-overview]

- Technical Constraints
  - Secure API key storage in environment variables
  - Handle OpenAI API rate limits and timeouts
  - Maintain response format compatibility with frontend

### Testing

- Test file location: Unit tests near services, integration tests under `tests/integration/`, E2E tests under
  `tests/e2e/` [Source: architecture/architecture-testing-strategy.md#test-file-organization]
- Test standards: Mock external APIs, test error scenarios, verify response processing [Source:
  architecture/architecture-testing-strategy.md#testing-best-practices]
- Frameworks/patterns: Jest for unit/integration with mocked OpenAI, Playwright for E2E [Source:
  architecture/architecture-tech-stack.md#tech-stack-overview]
- Story-specific: Test OpenAI integration, error handling, response processing, rate limiting

## Change Log

| Date | Version | Description | Author |
| ---- | ------- | ----------- | ------ |

## Dev Agent Record

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## Critical Dev Flow

1. **Pull latest main**: `git pull origin main`
2. **Create story branch**: `git checkout -b feature/story-1.5-live-ai-call-integration`
3. **Follow Red-Green-Refactor cycle**:
   - **Red**: Write failing tests first
   - **Green**: Implement minimal code to make tests pass
   - **Refactor**: Clean up code while keeping tests green
4. **Fulfill requirements**: Complete all acceptance criteria
5. **Verify quality**:
   - Run tests: `npm test && npm run test:e2e`
   - Run linting: `npm run lint`
   - Run type checking: `npm run type-check`
6. **Commit and push**: `git push origin feature/story-1.5-live-ai-call-integration`
7. **Create PR**: Submit pull request for review
8. **Monitor CI**: Use `gh pr checks` to watch CI status and ensure all checks pass

## QA Results
